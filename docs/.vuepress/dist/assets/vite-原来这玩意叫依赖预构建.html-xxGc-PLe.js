import{_ as o,r as i,o as c,c as t,a as e,b as s,e as a,d}from"./app-yWIsA8PS.js";const p={},l=d(`<h1 id="陈同学i前端-一起学vite-原来这玩意叫依赖预构建" tabindex="-1"><a class="header-anchor" href="#陈同学i前端-一起学vite-原来这玩意叫依赖预构建" aria-hidden="true">#</a> [陈同学i前端] 一起学Vite｜原来这玩意叫依赖预构建</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>大家好，我是陈同学，一枚野生前端开发者，感谢各位的<strong>点赞、收藏、评论</strong></p><p>近年来，前端领域技术更新迭代节奏较快，前端工程师们为了更好的进行项目开发、测试、构建、部署，开发出了各种各样的构建工具</p><p>像常见的Webpack、Rollup、Esbuild、Vite，每一类工具都有它的特点，均致力于提高前端领域的工程化水平</p><p>而工具出现的目标是<strong>解决前端工程当中的一些影响通性问题</strong></p><p>常见的痛点（需求点）有：模块化需求（ESM）、兼容高级语法、代码质量测试、静态资源处理、代码压缩、开发效率等</p><p>本节我们继续进行<code>Vite</code>知识的学习，具体安排如下：</p><ul><li>一起学Vite｜初识下一代的前端工具链</li><li>一起学Vite｜原来这玩意叫依赖预构建（本节）</li><li>一起学Vite｜实现第一个Vite插件</li><li>一起学Vite｜插件流水线</li><li>一起学Vite｜HMR，你好👋</li><li>一起学Vite｜模块联邦——代码共享的终极解决方案</li><li>一起学Vite｜简单手写开发服务器</li><li>一起学Vite｜简单手写打包器</li></ul><p>本文阅读成本与收益如下：</p><p>阅读耗时：<code>7mins</code></p><p>全文字数：<code>5k+</code></p><h2 id="预期效益" tabindex="-1"><a class="header-anchor" href="#预期效益" aria-hidden="true">#</a> 预期效益</h2><ul><li><code>Vite</code>为什么需要预构建</li><li>如何使用<code>Vite</code>预构建功能</li><li><code>Vite</code>预构建功能相关的配置</li><li><code>Vite</code>预构建流程</li></ul><h2 id="环境" tabindex="-1"><a class="header-anchor" href="#环境" aria-hidden="true">#</a> 环境</h2><p><code>Vite</code>版本：v3.2.3</p><p><code>Node</code>版本：v16.16.0</p><p><code>pnpm</code>版本：v7.9.0</p><h2 id="为什么要进行依赖预构建" tabindex="-1"><a class="header-anchor" href="#为什么要进行依赖预构建" aria-hidden="true">#</a> 为什么要进行依赖预构建</h2><p>由于Vite的开发服务是基于浏览器原生<code>ES</code>模块处理能力来实现的，故在使用开发服务器加载的模块资源理应全都为ESM格式的模块</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221126101942.png" alt="20221126101942"></p><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><ol><li>第三方依赖（node_modules）可能存在无ES格式产物的情况</li></ol><p>这种情况下在使用开发服务器时这类型的第三方依赖（无ES格式产物）便无法被解析执行</p><ol start="2"><li>请求瀑布流问题</li></ol><p>当第三方依赖的运行需要了很多其它依赖，所涉及<code>import</code>模块的数量较多时会触发大量的请求</p><p>而像Chrome限制了同一域名下最多只能并发6个HTTP请求，最终导致性能下降</p><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h3><p>为了解决以上两个问题，依赖预构建做了两件事情：</p><ul><li><p>将非 <code>ESM</code> 格式(如CommonJS)的产物转换为 <code>ESM</code> 格式，使其能被浏览器通过<code>&lt;script type=&quot;module&quot;&gt;&lt;script&gt;</code>的方式加载</p></li><li><p>把第三方库打包成一个模块文件（多个JS文件—&gt;单个JS文件），项目源码中每<code>import</code>一个第三方库仅会发起一个请求，从而优化了 <code>HTTP</code> 请求数量</p></li></ul><blockquote><p>依赖预构建仅会在开发模式下应用，并会使用 Esbuild 将依赖转为 ESM 模块。在生产构建中则会使用 @rollup/plugin-commonjs</p></blockquote><h2 id="如何使用vite预构建功能" tabindex="-1"><a class="header-anchor" href="#如何使用vite预构建功能" aria-hidden="true">#</a> 如何使用<code>Vite</code>预构建功能</h2><p>查看源码<code>initServer</code>（初始化开发服务器）可知，当我们在<code>Vite</code>配置文件中完全不提供<code>optimizeDeps</code>的属性对象时，<code>isDepsOptimizerEnabled</code>方法的返回值为true，即会调用<code>initDepsOptimizer</code>方法进行依赖预构建流程（scan、pre-bundle）</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129084904.png" alt="20221129084904"></p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129085126.png" alt="20221129085126"></p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129084342.png" alt="20221129084342"></p><p>官方文档当中提示<code>首次启动 vite 时，你可能会注意到打印出了以下信息</code>，但查阅源码后发现该段打印信息已经不复存在，执行<code>vite</code>命令后并不会打印相关信息</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129085916.png" alt="20221129085916"></p><p>若需要获取依赖scan、bundle的日志信息，可以执行</p><p><code>npx vite --debug --force</code></p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129091243.png" alt="20221129091243"></p><p>预构建完成后可于<code>node_modules/.vite/deps</code>目录查看到构建产物</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129091432.png" alt="20221129091432"></p><p>第一次启动项目后，后续的开发服务器启动默认会直接使用已有的缓存文件</p><p>若需要使缓存文件失效并重新进行预构建，则可以从以下几个方面进行</p><ol><li><code>package.json</code> 的 <code>dependencies</code> 字段（即增删改第三方依赖）并执行<code>npm install</code>，从而更新 <code>lock</code> 文件内容</li><li><code>optimizeDeps</code> 、 <code>mode</code> 、 <code>root</code> 、 <code>resolve</code> 、 <code>buildTarget</code> 、 <code>assetsInclude</code> 、 <code>plugins</code> 等配置内容</li><li>命令<code>npx vite --force</code>或在配置中<code>optimizeDeps.force = true</code>（强制清除原缓存预构建产物并重新生成）</li></ol><h2 id="vite预构建功能相关的配置" tabindex="-1"><a class="header-anchor" href="#vite预构建功能相关的配置" aria-hidden="true">#</a> <code>Vite</code>预构建功能相关的配置</h2><p><code>Vite</code>将与预构建相关的配置全都收敛到了<code>config.optimizeDeps</code>当中</p><p><code>optimizeDeps</code>属性对应的TS类型为<code>DepOptimizationOptions</code>，如下：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">DepOptimizationOptions</span> <span class="token operator">=</span> DepOptimizationConfig <span class="token operator">&amp;</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * By default, Vite will crawl your \`index.html\` to detect dependencies that
     * need to be pre-bundled. If \`build.rollupOptions.input\` is specified, Vite
     * will crawl those entry points instead.
     *
     * If neither of these fit your needs, you can specify custom entries using
     * this option - the value should be a fast-glob pattern or array of patterns
     * (https://github.com/mrmlnc/fast-glob#basic-syntax) that are relative from
     * vite project root. This will overwrite default entries inference.
     */</span>
    <span class="token comment">// 当默认扫描 HTML 入口文件的行为无法满足需求，比如项目入口为vue格式文件时，可以配置此项</span>
    entries<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * Force dep pre-optimization regardless of whether deps have changed.
     * <span class="token keyword">@experimental</span>
     */</span>
    <span class="token comment">// 是否开启强制进行依赖预构建行为</span>
    force<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">DepOptimizationConfig</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * Force optimize listed dependencies (must be resolvable import paths,
     * cannot be globs).
     */</span>
    <span class="token comment">// 用于提前预构建打包异步import（如：const a = import(&#39;xxx&#39;)）的第三方依赖</span>
    include<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * Do not optimize these dependencies (must be resolvable import paths,
     * cannot be globs).
     */</span>
    <span class="token comment">// 将某些依赖从预构建的过程中排除</span>
    exclude<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * Force ESM interop when importing for these dependencies. Some legacy
     * packages advertise themselves as ESM but use \`require\` internally
     * <span class="token keyword">@experimental</span>
     */</span>
    <span class="token comment">// 实验功能：应对一些第三方依赖声明了ESM格式但却使用require语法</span>
    needsInterop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * Options to pass to esbuild during the dep scanning and optimization
     *
     * Certain options are omitted since changing them would not be compatible
     * with Vite&#39;s dep optimization.
     *
     * - \`external\` is also omitted, use Vite&#39;s \`optimizeDeps.exclude\` option
     * - \`plugins\` are merged with Vite&#39;s dep plugin
     *
     * https://esbuild.github.io/api
     */</span>
    <span class="token comment">// 自定义esbuild相关的配置</span>
    esbuildOptions<span class="token operator">?</span><span class="token operator">:</span> Omit<span class="token operator">&lt;</span>BuildOptions_2<span class="token punctuation">,</span> <span class="token string">&#39;bundle&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;entryPoints&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;external&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;write&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;watch&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;outdir&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;outfile&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;outbase&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;outExtension&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;metafile&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * List of file extensions that can be optimized. A corresponding esbuild
     * plugin must exist to handle the specific extension.
     *
     * By default, Vite can optimize \`.mjs\`, \`.js\`, \`.ts\`, and \`.mts\` files. This option
     * allows specifying additional extensions.
     *
     * <span class="token keyword">@experimental</span>
     */</span>
    <span class="token comment">// 扩展的可处理文件后缀名，但必须提供对应的esbuild插件进行处理</span>
    extensions<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * Disables dependencies optimizations, true disables the optimizer during
     * build and dev. Pass &#39;build&#39; or &#39;dev&#39; to only disable the optimizer in
     * one of the modes. Deps optimization is enabled by default in dev only.
     * <span class="token keyword">@default</span> &#39;build&#39;
     * <span class="token keyword">@experimental</span>
     */</span>
    <span class="token comment">// 实验功能：在某一模式下禁用依赖预构建，默认值：build</span>
    disabled<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token string">&#39;build&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;dev&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vite预构建流程" tabindex="-1"><a class="header-anchor" href="#vite预构建流程" aria-hidden="true">#</a> <code>Vite</code>预构建流程</h2><blockquote><p>源码参考学习：https://github.com/vitejs/vite/blob/v3.2.3/packages/vite/src/node/optimizer/index.ts</p></blockquote><h3 id="缓存判断" tabindex="-1"><a class="header-anchor" href="#缓存判断" aria-hidden="true">#</a> 缓存判断</h3><p>由于在<code>Vite</code>v2.9版本前，默认的Vite预构建产物缓存目录为<code>node_modules/.vite</code>，故在v2.9后的<code>Vite</code>版本预构建前置行为中会判断是否存在旧版本缓存目录</p><p>具体判断条件：在<code>node_modules/.vite</code>目录下是否存在<code>_metadata.json</code>文件，若存在则直接清空<code>node_modules/.vite</code>目录</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221203120850.png" alt="20221203120850"></p><p>之后获取新版本下的<code>缓存目录</code>路径(node_modules/.vite/deps)，在缓存目录中找到<code>_metadata.json</code>并进行解析读取</p><p>将<u><code>_metadata.json</code>文件中解析出来的<code>hash</code>值</u>与<u><code>Vite</code>根据项目中包含的<code>lock</code>文件内容以及相关配置项信息进行hash得到的值</u>进行比较</p><p>若相同，则说明上次预构建产物结果无需进行变更，跳过预构建流程</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221203121617.png" alt="20221203121617"></p><p>若不相同，则表示关联的依赖信息有更新或已过期，需要进行依赖预构建</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221203230957.png" alt="20221203230957"></p><p>图示黄色区域为最近（2022-11）新增的<code>Vite</code>缓存判断的新逻辑，主要是为了支持在判断预构建缓存是否有效时，加入第三方依赖的<code>patch</code>代码用于<code>hash</code>，这样一来如果开发者修改了<code>patch</code>代码，则可使得预构建产物失效，从而重新触发预构建流程（<code>patch代码</code>指的是开发者修改第三方依赖所产生的代码）</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129093723.png" alt="20221129093723"></p><h3 id="依赖扫描" tabindex="-1"><a class="header-anchor" href="#依赖扫描" aria-hidden="true">#</a> 依赖扫描</h3><p>如果没有找到符合的预构建产物缓存，<code>Vite</code> 将为预构建行为进行源码扫描</p><h4 id="处理配置包含依赖" tabindex="-1"><a class="header-anchor" href="#处理配置包含依赖" aria-hidden="true">#</a> 处理配置包含依赖</h4><p>首先<code>Vite</code>先对已经知道需要进行预构建的依赖（<code>optimizeDeps.include</code>字符串数组）进行路径<code>resolve</code></p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204165138.png" alt="20221204165138"></p><p>图示黄框标注逻辑：提取<code>optimizeDeps.include</code>数组，遍历每一个元素，将字符串通过<code>normalizeId</code>方法进行格式化，然后检查依赖字符串是否已经存在，若不存在则进行<code>resolve</code>路径解析，最后将解析出来的模块路径<code>entry</code>作为<code>value</code>，以经过<code>normalizeId</code>方法处理的<code>id</code>（字符串）作为<code>key</code>存入<code>deps</code>对象</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204165819.png" alt="20221204165819"></p><p>准备好的<code>deps</code>格式如：（此处使用了pnpm，若使用npm路径关系上有区别）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">pinia</span><span class="token operator">:</span> <span class="token string">&#39;/Users/xxx/code/nodeProject/node_modules/.pnpm/pinia@2.0.26_mgnvym7yiazkylwwogi5r767ue/node_modules/pinia/dist/pinia.mjs&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着我们遍历<code>deps</code>对象获取到每一个依赖模块文件，通过<code>es-module-lexer</code>解析出每个依赖文件的<code>imports, exports, facade</code>信息，将这些信息封装成一个<code>Promise&lt;ExportsData&gt;</code>类型对象作为<code>exportsData</code>属性并联同<code>id</code>、<code>file</code>、<code>src</code>、<code>browserHash</code>属性组成<code>discovered</code>对象返回</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204171028.png" alt="20221204171028"></p><p>最终将<code>discovered</code>存储到元信息对象当中</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204202202.png" alt="20221204202202"></p><h4 id="入口文件扫描依赖" tabindex="-1"><a class="header-anchor" href="#入口文件扫描依赖" aria-hidden="true">#</a> 入口文件扫描依赖</h4><p>默认行为是扫描目录下的所有HTML文件（若提供了入口文件则对入口文件进行扫描），自动寻找关联的依赖项</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129100128.png" alt="20221129100128"></p><p>在<code>scanImports</code>方法内部主要会使用<code>Promise.all</code>并行执行 <code>build</code> 方法（Esbuild）处理多个入口文件（若有多个）</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221129100536.png" alt="20221129100536"></p><blockquote><p>这里的依赖扫描过程主要由<code>esbuildScanPlugin</code>插件处理各种case的模块文件，插件对各种模块文件的内容加载时进行的介入处理，比如：对于HTML文件，插件会识别出所有引入的module以及内联脚本代码，并将导入导出语句拼接成<code>js</code>字符串变量用于后面的逻辑 <img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204203233.png" alt="20221204203233"><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221204204212.png" alt="20221204204212"></p></blockquote><p>最后将这些依赖项作为预构建依赖的入口点，而预构建通过 <code>Esbuild</code> (Go语言)执行，所以执行耗时短</p><p>在服务器已经启动之后，如果遇到一个新的依赖关系导入，而这个依赖关系还没有在缓存中，<code>Vite</code> 将重新运行依赖构建进程并重新加载页面</p><h3 id="依赖打包" tabindex="-1"><a class="header-anchor" href="#依赖打包" aria-hidden="true">#</a> 依赖打包</h3><p>根据依赖扫描后得到的信息进行依赖打包</p><p>在打包之前<code>Vite</code>会先去寻找一个<strong>临时缓存目录</strong>（processingCacheDir），这个目录的作用在于<code>Vite</code>在执行Esbuild bundle流程时的输入目录指定为<strong>临时缓存目录</strong></p><p>从而与最终的<strong>缓存目录</strong>相隔离，即使最终bundle过程中出现了问题也不会对开发服务器启动后使用的最终<strong>缓存目录</strong>造成影响</p><p>处理逻辑：判断是否已经存在<strong>临时缓存目录</strong>，若已存在则清空目录内容，若不存在则创建<strong>临时缓存目录</strong></p><p>而后还会在<strong>临时缓存目录</strong>写入一个<code>package.json</code>文件，让所有存在于缓存目录中的模块文件最终都能够被识别为<code>ESM</code></p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221202174818.png" alt="20221202174818"></p><p>接下来<code>Vite</code>为依赖预构建<code>flatIdDeps</code>对象，对象的key为需要预构建的模块文件<strong>标识字符串</strong>，value则为在依赖扫描阶段提前处理好的由export、import语句构成的虚拟模块字符串</p><p>最终将对象传递给<code>esbuildDepPlugin</code>插件，最终插件执行于<code>Esbuild</code>中build-API的逻辑当中，进行关联第三方依赖的bundle</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221202175006.png" alt="20221202175006"></p><h3 id="元信息持久化" tabindex="-1"><a class="header-anchor" href="#元信息持久化" aria-hidden="true">#</a> 元信息持久化</h3><p>构建完成<code>Esbuild</code>根据<code>outDir</code>将产物输出到了前面逻辑所创建的临时缓存目录<code>processingCacheDir</code>当中，<code>Vite</code>拿到依赖预构建产生的<code>metadata信息</code>并将其写入到<code>node_modules/.vite/deps/_metadata.json</code>文件</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221202175935.png" alt="20221202175935"></p><h3 id="覆盖缓存目录" tabindex="-1"><a class="header-anchor" href="#覆盖缓存目录" aria-hidden="true">#</a> 覆盖缓存目录</h3><p>最终移除原本的缓存目录（depsCacheDir:<code>.vite/deps_temp</code>），并将临时缓存目录重命名为缓存目录<code>.vite/deps</code>,</p><p><img src="https://charlex-1307761018.cos.ap-guangzhou.myqcloud.com/image/20221202175909.png" alt="20221202175909"></p><p>致此，<strong>依赖预构建</strong>全流程就结束了</p><h2 id="讲到最后" tabindex="-1"><a class="header-anchor" href="#讲到最后" aria-hidden="true">#</a> 讲到最后</h2><p>本节文章讲述了<code>Vite</code><strong>依赖预构建</strong>相关的知识</p><p>一开始我们简单了解了一下为什么会有<strong>依赖预构建</strong>的出现，它的出现解决了什么样的问题，然后我们便可以带着这些问题看看<code>Vite</code>是如何解决的</p><p>接着在了解预构建实现流程原理之前，我们先学习了如何简单使用依赖预构建使用，另外也对预构建的配置项做了一定的了解</p><p>而<strong>依赖预构建</strong>的基本流程：缓存判断、依赖扫描、依赖打包、元信息持久化、覆盖缓存目录</p><p>我们逐个流程拆分，分别进行学习，<code>Vite</code>进行<strong>依赖预构建</strong>是建立在<code>Esbuild</code>构建能力基础上的，而<code>Vite</code>框架为了能够通过Esbuild的能力提升构建时性能，故通过编写<code>Esbuild</code>的插件用于构建过程，构建完成后需要保存本次预构建的元信息以及更新缓存目录</p><p>阅读完本篇文章，希望大家都能够对<code>依赖预构建</code>有一个更多深层次的认知</p><p>谢谢大家，我们下节再见！！！</p><blockquote><p>感谢各位看到这里，如果你觉得本节内容还不错的话，欢迎各位的<strong>点赞、收藏、评论</strong>，大家的支持是我做内容的最大动力</p></blockquote><blockquote><p>本文为作者原创，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利</p></blockquote><h2 id="参考补充" tabindex="-1"><a class="header-anchor" href="#参考补充" aria-hidden="true">#</a> 参考补充</h2>`,113),r={href:"https://cn.vitejs.dev/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://rollupjs.org/guide/en/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://juejin.cn/book/7050063811973218341",target:"_blank",rel:"noopener noreferrer"},g={href:"https://cn.vuejs.org/",target:"_blank",rel:"noopener noreferrer"};function v(b,k){const n=i("ExternalLinkIcon");return c(),t("div",null,[l,e("p",null,[e("a",r,[s("Vite官方文档"),a(n)])]),e("p",null,[e("a",u,[s("Rollup官方文档"),a(n)])]),e("p",null,[e("a",m,[s("Esbuild官方文档"),a(n)])]),e("p",null,[e("a",h,[s("掘金小册"),a(n)])]),e("p",null,[e("a",g,[s("Vue3文档"),a(n)])])])}const f=o(p,[["render",v],["__file","vite-原来这玩意叫依赖预构建.html.vue"]]);export{f as default};
